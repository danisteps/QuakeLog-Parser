Quake 3 Reports - Task 1 - Daniele Soares Passos


First of all, since this is a web based and a command line application, all business logic should be placed on the server side in order to keep all logic in one place, which would be good for application maintenance. Because the command line application is responsible for the log files reading all analysis should be saved on a repository. The repository platform doesn’t matter for the architecture because it will be dealing with a general interface so it is easier to change from one kind of database storing to another (for instance, if I would like to change from text file database to cache memory I would only have to change the repository creator). 
The main server entities are: Player (has player’s informations, such as name), Match (has match’s informations, such as start and end match time), Kill (has informations regarding kills, such as gun that was used) and PlayerMatch (has informations that relates to players and matches, such as the amount of kills and deaths that happened to a player during a specific match). PlayerMatch is the entity that stores the relationship between one Player and one Match. The combination of players and matches are unique. 
The server handles all business operations. The applications jobs is only to validate files, call the server and create a user friendly output. The server has two kinds of services: report reading and information recovering. To read a report (or log file) the service receives the file in a byte array for instance. The reading service could have 3 subroutines: reading, processing and results. The reading step will read each line and identify each information. About the processing steps, first it would identify that a match has started and creates a new entity (also creates a PlayerMatch entity to store every player at every match), and continue reading the file until the match has ended identifying when a player kills another and incrementing the entities killing count. By the end of the reading, it will store the results in a repository. The recovering service will get all player-match information from the repository to the application.
The server architecture is quite simple. It has a controller to handle all services incoming requests. The controller has two methods: ReadAndImport(byte[] file) and GetPlayerMatch(). ReadAndImport calls the reading service and GetPlayerMatch calls the recovering service, both services were described previously in this essay. The controller also has the responsibility to call a RepositoryFactory that creates the main repository used for the importation and recovering operations.
        The application tool has a console that calls a controller every time it needs to make an operation. Thus, the user would input a file path on the console line and give the command to import all files. The console validates the file (checks the existence and format extension) and makes sure everything is ok. After the validation, the console calls the controller and sends the file path as a parameter. The  controller handles all Player and Match operations, so it has methods like ReadAndImpotLog(string filePath) and GetAllMatches(). The method ReadAndImportLog is responsible to open file in order to get all bytes and call a service placed on the server side that handles all reading and saving report operations for the file. ReadAndImpotLog returns an indication that the importation was successful. The method GetAllMatches is responsible to call a service to recover all PlayerMatch saved on the database and call a MatchPresentationBuilder that reads the recovered entities and builds a presentation. MatchPresentationBuilder creates a user interface friendly presentation, that shows all informations about players, kills by player and, total count of kill for each match. All statistics are inside the entity PlayerMatch, thus, the builder only have to sort and count. 
        The web application has one view responsible to show user friendly informations about the rankings of the players. The view calls a facade that simplifies all controller operations for the user interface. The facade has a method GetAllPlayersRanking that is responsible to call a controller to recover all players’ informations. The controller has a method GetPlayers that calls a service on the server to recover player’s informations and builds a presentation to return to the view. The presentation builder is responsible to convert the entities recovered from the service (it should be a list of PlayerMatch) and create a presentation with the players ordered by the killing count. Since the PlayerMatch has all killing information for a match, it would simply create a hashset of players and read all PlayerMatch(es) in order to count the number of kills for every match.